<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Requests CSV Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; line-height: 1.35; padding: 18px; }
    label { font-weight: 600; }
    select { margin-left: 6px; }
    table { border-collapse: collapse; margin-top: 16px; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; }
    th { background: #f6f6f6; position: sticky; top: 0; }
    .controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .note { color: #666; font-size: 0.9em; }
    .error { color: #b00; }
  </style>
</head>
<body>
  <h2>Requests CSV Viewer</h2>

  <div class="controls" id="blockFilterWrap" style="display:none;">
    <label for="blockSelect">Block:</label>
    <select id="blockSelect"></select>
    <span class="note">
      Non-84: Gate → Sec./Section → Plot → Row → Grave • 84: Sec./Section → Row → Grave (Gate hidden)
    </span>
  </div>

  <div id="output"></div>

  <script>
    function parseCSV(text) {
      var rows = [], row = [], field = '', i = 0, inQuotes = false;
      while (i < text.length) {
        var ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (text[i+1] === '"') { field += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          }
          field += ch; i++; continue;
        } else {
          if (ch === '"') { inQuotes = true; i++; continue; }
          if (ch === ',') { rows.length || row.length; row.push(field); field=''; i++; continue; }
          if (ch === '\r') { i++; continue; }
          if (ch === '\n') { row.push(field); rows.push(row); row=[]; field=''; i++; continue; }
          field += ch; i++;
        }
      }
      row.push(field);
      if (!(row.length === 1 && row[0] === '' && rows.length > 0)) rows.push(row);
      while (rows.length && rows[rows.length-1].every(function(c){return String(c).trim()==='';})) rows.pop();
      return rows;
    }

    function naturalCompare(a, b) {
      var ax = String(a == null ? '' : a).trim();
      var bx = String(b == null ? '' : b).trim();
      if (ax === bx) return 0;
      var re = /(\d+|\D+)/g;
      var ta = ax.match(re) || [];
      var tb = bx.match(re) || [];
      var len = Math.max(ta.length, tb.length);
      for (var i = 0; i < len; i++) {
        var na = ta[i] != null ? ta[i] : '';
        var nb = tb[i] != null ? tb[i] : '';
        var ia = /^\d+$/.test(na);
        var ib = /^\d+$/.test(nb);
        if (ia && ib) {
          var da = parseInt(na, 10), db = parseInt(nb, 10);
          if (da !== db) return da - db;
        } else {
          if (na !== nb) return na.localeCompare(nb);
        }
      }
      return 0;
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, function(c){
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]);
      });
    }

    function buildTable(container, headers, rows) {
      var html = '<table><thead><tr>';
      headers.forEach(function(h){ html += `<th>${escapeHtml(h)}</th>`; });  // ✅ backtick closed correctly
      html += '</tr></thead><tbody>';
      for (var i=0;i<rows.length;i++) {
        var r = rows[i];
        html += '<tr>';
        for (var j=0;j<headers.length;j++) {
          var h = headers[j];
          var cell = r[h];
          html += `<td>${escapeHtml(cell == null ? '' : cell)}</td>`;        // ✅ no "??"
        }
        html += '</tr>';
      }
      html += '</tbody></table>';
      container.innerHTML = html;
    }

    var allRows = [];
    var headers = [];

    var ALWAYS_HIDE_LC = new Set(['birthdate','notes','problems','memorialid']);

    var blockWrap = document.getElementById('blockFilterWrap');
    var blockSelect = document.getElementById('blockSelect');
    var output = document.getElementById('output');

    function findHeader(candidates) {
      for (var k=0;k<candidates.length;k++) {
        var c = candidates[k].toLowerCase();
        for (var i=0;i<headers.length;i++) {
          if (headers[i].toLowerCase() === c) return headers[i];
        }
      }
      return null;
    }

    function hasAnyData(rows, header) {
      if (!header) return false;
      for (var i=0;i<rows.length;i++) {
        var v = rows[i][header];
        if (v != null && String(v).trim() !== '') return true;
      }
      return false;
    }

    async function loadCSV() {
      try {
        var res = await fetch('requests.csv', { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        var text = await res.text();

        var data = parseCSV(text);
        if (!data.length) { output.innerHTML = '<p class="error">No data found in requests.csv.</p>'; return; }

        headers = data[0].map(function(h){ return String(h).trim(); });

        var COL = {
          Block: findHeader(['Block']),
          Gate:  findHeader(['Gate']),
          Sec:   findHeader(['Sec.','Section','Sec']),
          Plot:  findHeader(['Plot']),
          Row:   findHeader(['Row']),
          Grave: findHeader(['Grave'])
        };

        var requiredMissing = [];
        if (!COL.Block) requiredMissing.push('Block');
        if (!COL.Row) requiredMissing.push('Row');
        if (!COL.Grave) requiredMissing.push('Grave');
        if (!COL.Gate && !COL.Sec) requiredMissing.push('Gate (or Section/Sec.)');
        if (requiredMissing.length) {
          output.innerHTML = '<p class="error">Missing required column(s): ' + requiredMissing.join(', ') + '</p>';
          return;
        }

        allRows = data.slice(1)
          .filter(function(r){ return r.some(function(c){ return String(c).trim() !== ''; }); })
          .map(function(r){
            var obj = {};
            headers.forEach(function(h, i){ obj[h] = (r[i] == null ? '' : String(r[i]).trim()); });
            return obj;
          });

        var blocksSet = {};
        for (var i=0;i<allRows.length;i++) {
          var bv = (allRows[i][COL.Block] == null ? '' : allRows[i][COL.Block]).trim();
          if (bv) blocksSet[bv] = true;
        }
        var blocks = Object.keys(blocksSet).sort(naturalCompare);

        blockSelect.innerHTML = blocks.map(function(v){
          return '<option value="'+escapeHtml(v)+'">'+escapeHtml(v)+'</option>';
        }).join('');
        blockWrap.style.display = 'flex';
        output.innerHTML = '<p class="note">Choose a Block to display rows.</p>';

        blockSelect.dataset.cols = JSON.stringify(COL);

      } catch (err) {
        output.innerHTML = '<p class="error">Failed to load requests.csv: ' + escapeHtml(err.message) + '</p>';
      }
    }

    blockSelect.addEventListener('change', function(){ renderForBlock(blockSelect.value); });

    function renderForBlock(selected) {
      var COL = JSON.parse(blockSelect.dataset.cols || '{}');
      var filtered = allRows.filter(function(r){
        var v = r[COL.Block];
        return (v == null ? '' : v).trim() === selected;
      });

      if (selected === '84') {
        filtered.sort(function(a,b){
          var s = naturalCompare(a[COL.Sec], b[COL.Sec]); if (s) return s;
          var r = naturalCompare(a[COL.Row], b[COL.Row]); if (r) return r;
          return naturalCompare(a[COL.Grave], b[COL.Grave]);
        });
      } else {
        filtered.sort(function(a,b){
          var g = naturalCompare(a[COL.Gate], b[COL.Gate]); if (g) return g;
          var s = naturalCompare(a[COL.Sec],  b[COL.Sec]);  if (s) return s;
          var p = naturalCompare(a[COL.Plot], b[COL.Plot]); if (p) return p;
          var r = naturalCompare(a[COL.Row],  b[COL.Row]);  if (r) return r;
          return naturalCompare(a[COL.Grave], b[COL.Grave]);
        });
      }

      var visible = headers.filter(function(h){ return !ALWAYS_HIDE_LC.has(h.toLowerCase()); });
      if (selected === '84' && COL.Gate) visible = visible.filter(function(h){ return h !== COL.Gate; });

      var secHasData  = hasAnyData(filtered, COL.Sec);
      var plotHasData = hasAnyData(filtered, COL.Plot);
      if (COL.Sec  && !secHasData)  visible = visible.filter(function(h){ return h !== COL.Sec; });
      if (COL.Plot && !plotHasData) visible = visible.filter(function(h){ return h !== COL.Plot; });

      buildTable(output, visible, filtered);
    }

    document.addEventListener('DOMContentLoaded', async function(){
      await loadCSV();
      if (blockSelect.options.length) {
        blockSelect.selectedIndex = 0;
        renderForBlock(blockSelect.value);
      }
    });
  </script>
</body>
</html>
