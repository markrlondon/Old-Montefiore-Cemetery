<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Requests CSV Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; line-height: 1.35; padding: 18px; }
    label { font-weight: 600; }
    input[type="text"] { margin-left: 6px; padding: 4px 6px; }
    table { border-collapse: collapse; margin-top: 16px; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; }
    th { background: #f6f6f6; position: sticky; top: 0; cursor: pointer; white-space: nowrap; }
    .controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; margin-bottom: 6px; }
    .error { color: #b00; }
    .note { color: #666; font-size: 0.9em; }

    th .sort-ind { font-size: 0.8em; opacity: 0.8; margin-left: 6px; display: inline-block; min-width: 1.2em; text-align: center; }
    th[data-sort-dir="1"] .sort-ind::after  { content: "▲"; }
    th[data-sort-dir="-1"] .sort-ind::after { content: "▼"; }
    th[data-sort-priority] .sort-prio::before {
      content: attr(data-sort-priority);
      font-size: 0.75em; border: 1px solid #aaa; border-radius: 999px; padding: 0 0.35em; margin-right: 4px; opacity: 0.8;
    }
  </style>
</head>
<body>
  <h2>Requests CSV Viewer</h2>

  <div class="controls" id="filterWrap" style="display:none;">
    <label for="blockInput">Block:</label>
    <input id="blockInput" type="text" list="blocksList" placeholder="Type a Block…" />
    <datalist id="blocksList"></datalist>

    <span id="gateWrap">
      <label for="gateInput">Gate:</label>
      <input id="gateInput" type="text" list="gatesList" placeholder="(optional) Gate…" />
      <datalist id="gatesList"></datalist>
    </span>

    <span id="secWrap" style="display:none;">
      <label for="secInput">Section:</label>
      <input id="secInput" type="text" list="secsList" placeholder="(optional) Section…" />
      <datalist id="secsList"></datalist>
    </span>
  </div>

  <span class="note">
    Click headers to sort; <b>Shift+Click</b> to add multi-column sorting.
  </span>

  <div id="output"></div>

  <script>
    /* ===== CSV parsing / comparators / utilities — unchanged ===== */
    function parseCSV(text) {
      var rows = [], row = [], field = '', i = 0, inQuotes = false;
      while (i < text.length) {
        var ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (text[i+1] === '"') { field += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          }
          field += ch; i++; continue;
        } else {
          if (ch === '"') { inQuotes = true; i++; continue; }
          if (ch === ',') { row.push(field); field=''; i++; continue; }
          if (ch === '\r') { i++; continue; }
          if (ch === '\n') { row.push(field); rows.push(row); row=[]; field=''; i++; continue; }
          field += ch; i++;
        }
      }
      row.push(field);
      if (!(row.length === 1 && row[0] === '' && rows.length > 0)) rows.push(row);
      while (rows.length && rows[rows.length-1].every(function(c){return String(c).trim()==='';})) rows.pop();
      return rows;
    }

    function naturalCompare(a, b) {
      var ax = String(a == null ? '' : a).trim();
      var bx = String(b == null ? '' : b).trim();
      if (ax === bx) return 0;
      var re = /(\d+|\D+)/g;
      var ta = ax.match(re) || [];
      var tb = bx.match(re) || [];
      var len = Math.max(ta.length, tb.length);
      for (var i = 0; i < len; i++) {
        var na = ta[i] != null ? ta[i] : '';
        var nb = tb[i] != null ? tb[i] : '';
        var ia = /^\d+$/.test(na);
        var ib = /^\d+$/.test(nb);
        if (ia && ib) {
          var da = parseInt(na, 10), db = parseInt(nb, 10);
          if (da !== db) return da - db;
        } else {
          if (na !== nb) return na.localeCompare(nb);
        }
      }
      return 0;
    }

    function parseDateMs(s) {
      if (s == null) return NaN;
      s = String(s).trim();
      if (!s) return NaN;
      var t = Date.parse(s);
      if (!isNaN(t)) return t;
      var m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
      if (m) {
        var mm = parseInt(m[1], 10)-1, dd = parseInt(m[2], 10), yy = parseInt(m[3], 10);
        if (yy < 100) yy += 2000;
        return new Date(yy, mm, dd).getTime();
      }
      var m2 = s.match(/^(\d{1,2})\s+([A-Za-z]{3,})\s+(\d{4})$/);
      if (m2) {
        var day = parseInt(m2[1],10), monStr = m2[2].toLowerCase(), year = parseInt(m2[3],10);
        var months = {"jan":0,"january":0,"feb":1,"february":1,"mar":2,"march":2,"apr":3,"april":3,"may":4,"jun":5,"june":5,"jul":6,"july":6,"aug":7,"august":7,"sep":8,"sept":8,"september":8,"oct":9,"october":9,"nov":10,"november":10,"dec":11,"december":11};
        if (months.hasOwnProperty(monStr)) return new Date(year, months[monStr], day).getTime();
      }
      return NaN;
    }
    function dateCompare(a, b) {
      var ta = parseDateMs(a), tb = parseDateMs(b);
      var aNaN = isNaN(ta), bNaN = isNaN(tb);
      if (aNaN && bNaN) return 0;
      if (aNaN) return 1;
      if (bNaN) return -1;
      return ta - tb;
    }
    function comparatorForColumn(colName) {
      if (!colName) return naturalCompare;
      var lc = String(colName).toLowerCase();
      if (lc === 'datecreated') return dateCompare;
      return naturalCompare;
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, function(c){
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]);
      });
    }
    function findHeader(candidates) {
      for (var k=0;k<candidates.length;k++) {
        var c = candidates[k].toLowerCase();
        for (var i=0;i<headers.length;i++) {
          if (headers[i].toLowerCase() === c) return headers[i];
        }
      }
      return null;
    }
    function findHeaderExact(name) {
      for (var i=0;i<headers.length;i++) if (headers[i] === name) return headers[i];
      return null;
    }
    function hasAnyData(rows, header) {
      if (!header) return false;
      for (var i=0;i<rows.length;i++) {
        var v = rows[i][header];
        if (v != null && String(v).trim() !== '') return true;
      }
      return false;
    }
    function uniqueSorted(values) {
      var seen = {};
      for (var i=0;i<values.length;i++) {
        var v = (values[i] == null ? '' : String(values[i]).trim());
        if (v) seen[v] = true;
      }
      return Object.keys(seen).sort(naturalCompare);
    }

    /* ===== State ===== */
    var allRows = [];
    var headers = [];
    var currentRows = [];
    var currentHeaders = [];
    var sortState = [];

    var ALWAYS_HIDE_LC = new Set(['birthdate','notes','problems','memorialid']);
    var HIDE_EXACT = new Set(['plot']); // hide lowercase 'plot' only

    var filterWrap = document.getElementById('filterWrap');
    var blockInput = document.getElementById('blockInput');
    var blocksList = document.getElementById('blocksList');
    var gateWrap = document.getElementById('gateWrap');
    var gateInput = document.getElementById('gateInput');
    var gatesList = document.getElementById('gatesList');
    var secWrap = document.getElementById('secWrap');
    var secInput = document.getElementById('secInput');
    var secsList = document.getElementById('secsList');
    var output = document.getElementById('output');

    /* === NEW: Make datalist show all options on click / down-arrow === */
    function enableShowAllOnClick(inputEl) {
      // Clicking the input (including the chevron) with a non-empty value:
      // temporarily clear value so the datalist shows ALL options.
      inputEl.addEventListener('mousedown', function() {
        if (inputEl.value) {
          inputEl.dataset.prev = inputEl.value;
          inputEl.value = '';
          inputEl.dataset.justCleared = '1';
        }
      });
      // Pressing ArrowDown should also reveal all options.
      inputEl.addEventListener('keydown', function(e) {
        if (e.key === 'ArrowDown' && inputEl.value) {
          inputEl.dataset.prev = inputEl.value;
          inputEl.value = '';
          inputEl.dataset.justCleared = '1';
        }
      });
      // If user leaves the field without selecting anything, restore.
      inputEl.addEventListener('blur', function() {
        if (inputEl.dataset.justCleared === '1' && inputEl.value === '') {
          inputEl.value = inputEl.dataset.prev || '';
        }
        inputEl.dataset.justCleared = '';
      });
      // If user types or selects an option, don't restore.
      inputEl.addEventListener('input', function() {
        inputEl.dataset.justCleared = '';
      });
    }

    /* ===== Table render & multi-sort ===== */
    function buildTable(container, headersToShow, rows) {
      currentRows = rows.slice();
      currentHeaders = headersToShow.slice();

      var html = '<table><thead><tr>';
      headersToShow.forEach(function(h){
        var idx = sortState.findIndex(function(s){ return s.col === h; });
        var prio = idx >= 0 ? (idx + 1) : '';
        var dir = idx >= 0 ? String(sortState[idx].dir) : '';
        html += '<th data-col="'+escapeHtml(h)+'"'
             +  (dir ? ' data-sort-dir="'+dir+'"' : '')
             +  (prio ? ' data-sort-priority="'+prio+'"' : '')
             +  '>'
             +  escapeHtml(h)
             +  '<span class="sort-ind"><span class="sort-prio"></span></span>'
             +  '</th>';
      });
      html += '</tr></thead><tbody>';
      rows.forEach(function(r){
        html += '<tr>';
        headersToShow.forEach(function(h){
          var cell = r[h];
          html += '<td>'+escapeHtml(cell == null ? '' : cell)+'</td>';
        });
        html += '</tr>';
      });
      html += '</tbody></table>';
      container.innerHTML = html;

      var ths = container.querySelectorAll("th");
      ths.forEach(function(th){
        var pr = th.getAttribute("data-sort-priority");
        if (pr) th.querySelector(".sort-prio").textContent = pr;
      });

      attachHeaderSortHandlers(container);
    }

    function attachHeaderSortHandlers(container) {
      var ths = container.querySelectorAll("th");
      ths.forEach(function(th){
        th.addEventListener("click", function(e){
          var col = th.getAttribute("data-col");
          var idx = sortState.findIndex(function(s){ return s.col === col; });

          if (e.shiftKey) {
            if (idx === -1) sortState.push({ col: col, dir: 1 });
            else sortState[idx].dir = -sortState[idx].dir;
          } else {
            if (idx === 0 && sortState.length > 0) {
              sortState[0].dir = -sortState[0].dir;
            } else {
              sortState = [{ col: col, dir: 1 }];
            }
          }

          applyMultiSort();
          buildTable(container, currentHeaders, currentRows);
        });
      });
    }

    function comparatorChain() {
      return sortState.map(function(s){
        return { key: s.col, dir: s.dir, cmp: comparatorForColumn(s.col) };
      });
    }
    function applyMultiSort() {
      if (!sortState.length) return;
      var comps = comparatorChain();
      var decorated = currentRows.map(function(r, i){ return { r:r, i:i }; });
      decorated.sort(function(A, B){
        var a = A.r, b = B.r;
        for (var k=0;k<comps.length;k++) {
          var c = comps[k];
          var res = c.cmp(a[c.key], b[c.key]);
          if (res !== 0) return res * c.dir;
        }
        return A.i - B.i;
      });
      currentRows = decorated.map(function(x){ return x.r; });
    }

    /* ===== Load CSV & UI ===== */
    async function loadCSV() {
      try {
        var res = await fetch('requests.csv', { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        var text = await res.text();
        var data = parseCSV(text);
        if (!data.length) { output.innerHTML = '<p class="error">No data found in requests.csv.</p>'; return; }

        headers = data[0].map(function(h){ return String(h).trim(); });

        var COL = {
          Block: findHeader(['Block']),
          Gate:  findHeader(['Gate']),
          Sec:   findHeader(['Sec.','Section','Sec']),
          Plot:  findHeaderExact('Plot'),
          Row:   findHeader(['Row']),
          Grave: findHeader(['Grave']),
          DateCreated: findHeader(['dateCreated'])
        };
        window.__COL = COL;

        var missing = [];
        if (!COL.Block) missing.push('Block');
        if (!COL.Row)   missing.push('Row');
        if (!COL.Grave) missing.push('Grave');
        if (!COL.Gate && !COL.Sec) missing.push('Gate (or Section/Sec.)');
        if (missing.length) {
          output.innerHTML = '<p class="error">Missing required column(s): ' + missing.join(', ') + '</p>';
          return;
        }

        allRows = data.slice(1)
          .filter(function(r){ return r.some(function(c){ return String(c).trim() !== ''; }); })
          .map(function(r){
            var obj = {};
            headers.forEach(function(h, i){ obj[h] = (r[i] == null ? '' : String(r[i]).trim()); });
            return obj;
          });

        var blocks = uniqueSorted(allRows.map(function(r){ return r[COL.Block]; }));
        blocksList.innerHTML = blocks.map(function(v){ return '<option value="'+escapeHtml(v)+'"></option>'; }).join('');

        filterWrap.style.display = 'flex';

        if (blocks.length) {
          blockInput.value = blocks[0];
          updateGateOrSectionUI(blockInput.value);
          populateGateOrSectionDatalist();
          renderForFilters();

          // Enable the "show all on click/down-arrow" behavior
          enableShowAllOnClick(gateInput);
          enableShowAllOnClick(secInput);
        }

      } catch (err) {
        output.innerHTML = '<p class="error">Failed to load requests.csv: ' + escapeHtml(err.message) + '</p>';
      }
    }

    function isBlock84() {
      return String(blockInput.value || '').trim() === '84';
    }

    function updateGateOrSectionUI(blockVal) {
      if (String(blockVal || '').trim() === '84') {
        gateWrap.style.display = 'none';
        secWrap.style.display = 'inline';
      } else {
        secWrap.style.display = 'none';
        gateWrap.style.display = 'inline';
      }
    }

    function populateGateOrSectionDatalist() {
      var COL = window.__COL || {};
      var bv = String(blockInput.value || '').trim();
      var subset = allRows.filter(function(r){ return String(r[COL.Block] || '').trim() === bv; });

      gatesList.innerHTML = '';
      secsList.innerHTML = '';

      if (!bv || subset.length === 0) return;

      if (isBlock84()) {
        var secs = uniqueSorted(subset.map(function(r){ return r[COL.Sec]; }));
        secsList.innerHTML = secs.map(function(v){ return '<option value="'+escapeHtml(v)+'"></option>'; }).join('');
      } else {
        var gates = uniqueSorted(subset.map(function(r){ return r[COL.Gate]; }));
        gatesList.innerHTML = gates.map(function(v){ return '<option value="'+escapeHtml(v)+'"></option>'; }).join('');
      }
    }

    function renderForFilters() {
      var COL = window.__COL || {};
      var bval = String(blockInput.value || '').trim();
      var filtered = allRows.filter(function(r){
        return String(r[COL.Block] || '').trim() === bval;
      });

      if (isBlock84()) {
        var sVal = String(secInput.value || '').trim();
        if (sVal) filtered = filtered.filter(function(r){ return String(r[COL.Sec] || '').trim() === sVal; });

        filtered.sort(function(a,b){
          var s = naturalCompare(a[COL.Sec], b[COL.Sec]); if (s) return s;
          var r = naturalCompare(a[COL.Row], b[COL.Row]); if (r) return r;
          return naturalCompare(a[COL.Grave], b[COL.Grave]);
        });
      } else {
        var gVal = String(gateInput.value || '').trim();
        if (gVal) filtered = filtered.filter(function(r){ return String(r[COL.Gate] || '').trim() === gVal; });

        filtered.sort(function(a,b){
          var g = naturalCompare(a[COL.Gate], b[COL.Gate]); if (g) return g;
          var s = naturalCompare(a[COL.Sec],  b[COL.Sec]);  if (s) return s;
          var p = naturalCompare(a[COL.Plot], b[COL.Plot]); if (p) return p;
          var r = naturalCompare(a[COL.Row],  b[COL.Row]);  if (r) return r;
          return naturalCompare(a[COL.Grave], b[COL.Grave]);
        });
      }

      var visible = headers.filter(function(h){
        if (ALWAYS_HIDE_LC.has(h.toLowerCase())) return false;
        if (HIDE_EXACT.has(h)) return false;
        return true;
      });
      if (isBlock84() && COL.Gate) visible = visible.filter(function(h){ return h !== COL.Gate; });

      var secHasData  = hasAnyData(filtered, COL.Sec);
      var plotHasData = hasAnyData(filtered, COL.Plot);
      if (COL.Sec  && !secHasData)  visible = visible.filter(function(h){ return h !== COL.Sec; });
      if (COL.Plot && !plotHasData) visible = visible.filter(function(h){ return h !== COL.Plot; });

      sortState = [];
      buildTable(output, visible, filtered);
    }

    // Debounced handlers
    var t1=null, t2=null, t3=null;
    blockInput.addEventListener('input', function(){
      clearTimeout(t1);
      t1 = setTimeout(function(){
        updateGateOrSectionUI(blockInput.value);

        gateInput.value = '';
        secInput.value  = '';

        populateGateOrSectionDatalist();
        renderForFilters();
      }, 150);
    });
    gateInput.addEventListener('input', function(){
      clearTimeout(t2);
      t2 = setTimeout(renderForFilters, 150);
    });
    secInput.addEventListener('input', function(){
      clearTimeout(t3);
      t3 = setTimeout(renderForFilters, 150);
    });

    document.addEventListener('DOMContentLoaded', loadCSV);
  </script>
</body>
</html>
