<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Old Montefiore Cemetery Photo Requests</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; line-height: 1.35; padding: 18px; }
    label { font-weight: 600; }
    input[type="text"], select { margin-left: 6px; padding: 4px 6px; }
    table { border-collapse: collapse; margin-top: 16px; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; }
    th { background: #f6f6f6; position: sticky; top: 0; cursor: pointer; white-space: nowrap; }
    .controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; margin-bottom: 6px; }
    .error { color: #b00; }
    .note { color: #666; font-size: 0.9em; }

    /* Sort indicators (hidden to save width) */
    th .sort-ind::after { content: none !important; }
    th .sort-ind { display: none !important; }

    /* dateCreated column: right align + padding + monospace */
    .right { text-align: right; padding-right: 2.5em; font-family: monospace; }

    /* --- Block combobox styles --- */
    .cb { position: relative; display: inline-flex; align-items: stretch; }
    .cb input { padding-right: 2em; }
    .cb .cb-toggle {
      position: absolute; right: 0; top: 0; height: 100%;
      border: 0; background: transparent; padding: 0 6px; cursor: pointer;
      font-size: 1rem; line-height: 1; color: #333;
    }
    .cb .cb-list {
      position: absolute; z-index: 10; left: 0; right: 0; top: calc(100% + 2px);
      list-style: none; margin: 0; padding: 4px 0; max-height: 240px; overflow: auto;
      background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 6px 18px rgba(0,0,0,.08);
      display: none;
    }
    .cb .cb-list.open { display: block; }
    .cb .cb-option { padding: 6px 10px; cursor: pointer; white-space: nowrap; }
    .cb .cb-option:hover, .cb .cb-option[aria-selected="true"] { background: #eef3ff; }
  </style>
</head>
<body>
  <h2>Old Montefiore Cemetery Photo Requests</h2>

  <div class="controls" id="filterWrap" style="display:none;">
    <label for="blockInput">Block:</label>
    <div class="cb" id="blockCombo">
      <input id="blockInput"
             type="text"
             placeholder="Leave empty to show all Blocks…"
             autocomplete="off"
             aria-haspopup="listbox"
             aria-expanded="false"
             aria-controls="blockListbox" />
      <button type="button" class="cb-toggle" aria-label="Open menu" tabindex="-1">▾</button>
      <ul id="blockListbox" class="cb-list" role="listbox"></ul>
    </div>

    <span id="gateWrap">
      <label for="gateSelect">Gate:</label>
      <select id="gateSelect"></select>
      <span id="graveCount" style="margin-left:8px; font-weight:600; color:#555;"></span>
    </span>
  </div>

  <span class="note">
    Click headers to sort; <b>Shift+Click</b> to add multi-column sorting.
  </span>

  <div id="output"></div>

  <script>
    /* ================= CSV parser ================= */
    function parseCSV(text) {
      var rows = [], row = [], field = '', i = 0, inQuotes = false;
      while (i < text.length) {
        var ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (text[i+1] === '"') { field += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          }
          field += ch; i++; continue;
        } else {
          if (ch === '"') { inQuotes = true; i++; continue; }
          if (ch === ',') { row.push(field); field=''; i++; continue; }
          if (ch === '\r') { i++; continue; }
          if (ch === '\n') { row.push(field); rows.push(row); row=[]; field=''; i++; continue; }
          field += ch; i++;
        }
      }
      row.push(field);
      if (!(row.length === 1 && row[0] === '' && rows.length > 0)) rows.push(row);
      while (rows.length && rows[rows.length-1].every(function(c){return String(c).trim()==='';})) rows.pop();
      return rows;
    }

    /* ================= Comparators ================= */
    function naturalCompare(a, b) {
      var ax = String(a == null ? '' : a).trim();
      var bx = String(b == null ? '' : b).trim();
      if (ax === bx) return 0;
      var re = /(\d+|\D+)/g;
      var ta = ax.match(re) || [];
      var tb = bx.match(re) || [];
      var len = Math.max(ta.length, tb.length);
      for (var i = 0; i < len; i++) {
        var na = ta[i] != null ? ta[i] : '';
        var nb = tb[i] != null ? tb[i] : '';
        var ia = /^\d+$/.test(na);
        var ib = /^\d+$/.test(nb);
        if (ia && ib) {
          var da = parseInt(na, 10), db = parseInt(nb, 10);
          if (da !== db) return da - db;
        } else {
          if (na !== nb) return na.localeCompare(nb);
        }
      }
      return 0;
    }
    function parseDateMs(s) {
      if (s == null) return NaN;
      s = String(s).trim();
      if (!s) return NaN;
      var t = Date.parse(s);
      if (!isNaN(t)) return t;
      var m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
      if (m) {
        var mm = parseInt(m[1], 10)-1, dd = parseInt(m[2], 10), yy = parseInt(m[3], 10);
        if (yy < 100) yy += 2000;
        return new Date(yy, mm, dd).getTime();
      }
      return NaN;
    }
    function dateCompare(a, b) {
      var ta = parseDateMs(a), tb = parseDateMs(b);
      var aNaN = isNaN(ta), bNaN = isNaN(tb);
      if (aNaN && bNaN) return 0;
      if (aNaN) return 1;
      if (bNaN) return -1;
      return ta - tb;
    }
    function comparatorForColumn(colName) {
      if (!colName) return naturalCompare;
      var lc = String(colName).toLowerCase();
      if (lc === 'datecreated') return dateCompare;
      return naturalCompare;
    }

    /* ================= Utilities ================= */
    function escapeHtml(s) {
      return String(s == null ? '' : s).replace(/[&<>"']/g, function(c){
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]);
      });
    }
    function uniqueSorted(values) {
      var seen = {};
      for (var i=0;i<values.length;i++) {
        var v = (values[i] == null ? '' : String(values[i]).trim());
        if (v) seen[v] = true;
      }
      return Object.keys(seen).sort(naturalCompare);
    }
    function readFiltersFromURL() {
      var p = new URLSearchParams(location.search);
      return {
        block: (p.get('block') || '').trim(),
        gate:  (p.get('gate')  || 'All').trim()
      };
    }
    function setFiltersAndReload(blockVal, gateVal) {
      var p = new URLSearchParams();
      if (blockVal) p.set('block', blockVal);
      if (gateVal && gateVal !== 'All') p.set('gate', gateVal);
      var qs = p.toString();
      location.search = qs ? ('?' + qs) : location.pathname; // full refresh
    }

    /* ================= State ================= */
    var allRows = [];
    var headers = [];
    var currentRows = [];
    var currentHeaders = [];
    var sortState = []; // [{col, dir}]
    var ALL_HIDE_LC = new Set(['birthdate','notes','problems','memorialid','memorial','section','sec.','sec']);
    var HIDE_EXACT = new Set(['plot']); // hide lowercase 'plot', keep 'Plot'

    var filterWrap = document.getElementById('filterWrap');
    var blockInput = document.getElementById('blockInput');
    var gateSelect = document.getElementById('gateSelect');
    var output = document.getElementById('output');

    var COL = {}; // resolved column names

    /* ================= Table render & sorting ================= */
    function buildTable(container, headersToShow, rows) {
      currentRows = rows.slice();
      currentHeaders = headersToShow.slice();

      var html = '<table><thead><tr>';
      headersToShow.forEach(function(h){
        var idx = sortState.findIndex(function(s){ return s.col === h; });
        var prio = idx >= 0 ? (idx + 1) : '';
        var dir = idx >= 0 ? String(sortState[idx].dir) : '';
        var cls = (String(h).toLowerCase() === 'datecreated') ? ' class="right"' : '';
        html += '<th data-col="'+escapeHtml(h)+'"'
             +  (dir ? ' data-sort-dir="'+dir+'"' : '')
             +  (prio ? ' data-sort-priority="'+prio+'"' : '')
             +  cls + '>'
             +  escapeHtml(h)
             +  '<span class="sort-ind"><span class="sort-prio"></span></span>'
             +  '</th>';
      });
      html += '</tr></thead><tbody>';

      rows.forEach(function(r){
        html += '<tr>';
        headersToShow.forEach(function(h){
          var cell = r[h];

          // Year: 1900 -> "unk"
          if (h.toLowerCase() === 'year' && String(cell).trim() === '1900') {
            cell = 'unk';
          }

          // Link First Name / Last Name using hidden Memorial number
          var memorialHeader = COL.Memorial; // resolved earlier
          if ((h.toLowerCase() === 'first name' || h.toLowerCase() === 'lastname' || h.toLowerCase() === 'last name') && memorialHeader) {
            var memId = String(r[memorialHeader] || '').trim();
            if (memId) {
              var url = 'https://www.findagrave.com/memorial/' + encodeURIComponent(memId);
              if (cell != null && String(cell).trim() !== '') {
                cell = '<a href="' + url + '" target="_blank" rel="noopener noreferrer">' + escapeHtml(cell) + '</a>';
              }
            }
          }

          var cls = (String(h).toLowerCase() === 'datecreated') ? ' class="right"' : '';
          html += '<td'+cls+'>'+ (cell == null ? '' : cell) +'</td>';
        });
        html += '</tr>';
      });

      html += '</tbody></table>';
      container.innerHTML = html;

      // populate sort priority numbers (if you want to keep them; arrows are hidden)
      var ths = container.querySelectorAll("th");
      ths.forEach(function(th){
        var pr = th.getAttribute("data-sort-priority");
        if (pr) {
          var prSpan = th.querySelector(".sort-prio");
          if (prSpan) prSpan.textContent = pr;
        }
      });

      attachHeaderSortHandlers(container);
    }

    function attachHeaderSortHandlers(container) {
      var ths = container.querySelectorAll("th");
      ths.forEach(function(th){
        th.addEventListener("click", function(e){
          var col = th.getAttribute("data-col");
          var idx = sortState.findIndex(function(s){ return s.col === col; });

          if (e.shiftKey) {
            if (idx === -1) sortState.push({ col: col, dir: 1 });
            else sortState[idx].dir = -sortState[idx].dir;
          } else {
            if (idx === 0 && sortState.length > 0) {
              sortState[0].dir = -sortState[0].dir;
            } else {
              sortState = [{ col: col, dir: 1 }];
            }
          }

          applyMultiSort();
          buildTable(container, currentHeaders, currentRows);
        });
      });
    }

    function comparatorChain() {
      return sortState.map(function(s){
        return { key: s.col, dir: s.dir, cmp: comparatorForColumn(s.col) };
      });
    }
    function applyMultiSort() {
      if (!sortState.length) return;
      var comps = comparatorChain();
      var decorated = currentRows.map(function(r, i){ return { r:r, i:i }; });
      decorated.sort(function(A, B){
        var a = A.r, b = B.r;
        for (var k=0;k<comps.length;k++) {
          var c = comps[k];
          var res = c.cmp(a[c.key], b[c.key]);
          if (res !== 0) return res * c.dir;
        }
        return A.i - B.i; // stable
      });
      currentRows = decorated.map(function(x){ return x.r; });
    }

    /* ================= Gate dropdown ================= */
    function setOptions(selectEl, values) {
      var html = '<option value="All">All</option>';
      for (var i=0;i<values.length;i++) {
        var v = values[i];
        html += '<option value="'+escapeHtml(v)+'">'+escapeHtml(v)+'</option>';
      }
      selectEl.innerHTML = html;
      selectEl.value = 'All';
    }

    // Populate using the CURRENT Block input (dynamic, no refresh)
    function populateGateDropdown() {
      var bv = String(blockInput.value || '').trim();
      var subset = allRows;
      if (bv) subset = subset.filter(function(r){ return String(r[COL.Block] || '').trim() === bv; });
      var gates = uniqueSorted(subset.map(function(r){ return r[COL.Gate]; }));
      setOptions(gateSelect, gates);
      gateSelect.value = 'All';
    }

    /* ================= Filtering & rendering (reads URL) ================= */
    var allRowsFiltered = [];

    function renderForFilters(){
      var params = readFiltersFromURL();
      var bv  = params.block;             // from URL
      var gVal = params.gate || 'All';    // from URL

      // Reflect values into controls visually
      blockInput.value = bv;
      // Build Gates for this block, then set selected gate
      (function(){
        var subset = allRows;
        if (bv) subset = subset.filter(function(r){ return String(r[COL.Block] || '').trim() === bv; });
        var gates = uniqueSorted(subset.map(function(r){ return r[COL.Gate]; }));
        setOptions(gateSelect, gates);
        if ([].slice.call(gateSelect.options).some(function(o){ return o.value === gVal; })) {
          gateSelect.value = gVal;
        }
      })();

      // Filter rows
      var filtered = allRows.slice();
      if (bv) {
        filtered = filtered.filter(function(r){
          return String(r[COL.Block] || '').trim() === bv;
        });
      }
      if (gVal && gVal !== 'All') {
        filtered = filtered.filter(function(r){
          return String(r[COL.Gate] || '').trim() === gVal;
        });
      }

      // Initial sort
      if (!bv) {
        filtered.sort(function(a,b){
          var B = naturalCompare(a[COL.Block], b[COL.Block]); if (B) return B;
          var g = naturalCompare(a[COL.Gate],  b[COL.Gate]);  if (g) return g;
          var p = naturalCompare(a[COL.Plot],  b[COL.Plot]);  if (p) return p;
          var r = naturalCompare(a[COL.Row],   b[COL.Row]);   if (r) return r;
          return naturalCompare(a[COL.Grave],  b[COL.Grave]);
        });
      } else {
        filtered.sort(function(a,b){
          var g = naturalCompare(a[COL.Gate], b[COL.Gate]); if (g) return g;
          var p = naturalCompare(a[COL.Plot], b[COL.Plot]); if (p) return p;
          var r = naturalCompare(a[COL.Row],  b[COL.Row]);  if (r) return r;
          return naturalCompare(a[COL.Grave], b[COL.Grave]);
        });
      }

      // Visible columns baseline
      var visible = headers.filter(function(h){
        if (ALL_HIDE_LC.has(h.toLowerCase())) return false;
        if (HIDE_EXACT.has(h)) return false; // exact lowercase 'plot'
        return true;
      });

      // Plot conditional on data presence
      if (COL.Plot) {
        var plotHasData = filtered.some(function(row){
          var v = row[COL.Plot];
          return v != null && String(v).trim() !== '';
        });
        if (!plotHasData) visible = visible.filter(function(h){ return h !== COL.Plot; });
      }

      sortState = []; // reset user sort on URL-based render
      allRowsFiltered = filtered;
      buildTable(output, visible, filtered);

      // Grave count label
      var graveCountEl = document.getElementById('graveCount');
      if (graveCountEl) graveCountEl.textContent = filtered.length + ' graves';
    }

    /* ================= Block combobox (type or pick) ================= */
    function initBlockCombo(blockValues, options) {
      var onConfirm = options && typeof options.onConfirm === 'function' ? options.onConfirm : null;

      var root = document.getElementById('blockCombo');
      var input = document.getElementById('blockInput');
      var list  = document.getElementById('blockListbox');
      var toggle = root.querySelector('.cb-toggle');
      var all = (blockValues || []).slice();
      var activeIndex = -1;

      all.sort(naturalCompare);

      function buildList(items) {
        list.innerHTML = '';
        items.forEach(function(v){
          var li = document.createElement('li');
          li.className = 'cb-option';
          li.role = 'option';
          li.textContent = v;
          li.dataset.value = v;
          li.addEventListener('mousedown', function(e){
            e.preventDefault();
            selectValue(v);
          });
          list.appendChild(li);
        });
        activeIndex = -1;
      }


      function openList(showAll) {
  if (showAll) buildList(all);
  else filterList(input.value);

  list.classList.add('open');
  input.setAttribute('aria-expanded', 'true');

  // ✅ ensure current value is highlighted and scrolled into view
  var currentVal = String(input.value || '').trim();
  if (currentVal) {
    var children = Array.from(list.children);
    var idx = children.findIndex(li => String(li.dataset.value) === currentVal);
    if (idx >= 0) {
      activeIndex = idx;
      children.forEach(li => li.removeAttribute('aria-selected'));
      var el = children[idx];
      el.setAttribute('aria-selected','true');
      el.scrollIntoView({ block: 'nearest' });
    }
  }
}

      function closeList() {
        list.classList.remove('open');
        input.setAttribute('aria-expanded', 'false');
        clearActive();
      }
      function isOpen(){ return list.classList.contains('open'); }

      function filterList(q) {
        q = String(q || '').trim().toLowerCase();
        var filtered = q ? all.filter(function(v){ return String(v).toLowerCase().includes(q); }) : all.slice();
        buildList(filtered);
      }

      function clearActive() {
        Array.from(list.children).forEach(function(li){ li.removeAttribute('aria-selected'); });
        activeIndex = -1;
      }
      function moveActive(delta) {
        if (!isOpen()) openList(true);
        var n = list.children.length;
        if (!n) return;
        activeIndex = (activeIndex + delta + n) % n;
        Array.from(list.children).forEach(function(li){ li.removeAttribute('aria-selected'); });
        var el = list.children[activeIndex];
        el.setAttribute('aria-selected','true');
        el.scrollIntoView({ block: 'nearest' });
      }

      function selectValue(v) {
        input.value = v;
        closeList();
        if (onConfirm) onConfirm(v);
      }

      function dispatchInput(el) {
        var evt = new Event('input', { bubbles: true });
        el.dispatchEvent(evt);
      }

      // UX: click shows FULL list
      input.addEventListener('click', function(){ openList(true); });
      // Typing opens/filters
      input.addEventListener('input', function(){
        if (!isOpen()) openList(false); else filterList(input.value);
      });

      input.addEventListener('keydown', function(e){
        if (e.key === 'ArrowDown') { e.preventDefault(); moveActive(1); return; }
        if (e.key === 'ArrowUp')   { e.preventDefault(); moveActive(-1); return; }
        if (e.key === 'Escape')    { if (isOpen()) { e.preventDefault(); closeList(); } return; }
        if (e.key === 'Enter' || e.key === 'NumpadEnter') {
          e.preventDefault();
          if (isOpen()) {
            if (activeIndex >= 0) {
              var el = list.children[activeIndex];
              if (el) selectValue(el.dataset.value);
            } else {
              closeList();
              if (onConfirm) onConfirm(input.value.trim());
              else dispatchInput(input);
            }
          } else {
            if (onConfirm) onConfirm(input.value.trim());
            else dispatchInput(input);
          }
          return;
        }
      });

      // Toggle button: always show full
      toggle.addEventListener('mousedown', function(e){
        e.preventDefault();
        if (isOpen()) closeList(); else openList(true);
      });

      // Click outside closes
      document.addEventListener('mousedown', function(e){
        if (!root.contains(e.target)) closeList();
      });

      // Initial population
      buildList(all);
    }

    /* ================= Load CSV & boot ================= */
    document.addEventListener('DOMContentLoaded', loadCSV);

    async function loadCSV() {
      try {
        var res = await fetch('requests.csv', { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        var text = await res.text();
        var data = parseCSV(text);
        if (!data.length) { output.innerHTML = '<p class="error">No data found in requests.csv.</p>'; return; }

        headers = data[0].map(function(h){ return String(h).trim(); });

        // Resolve columns
        COL = {
          Block: headers.find(function(h){ return h.toLowerCase() === 'block'; }),
          Gate:  headers.find(function(h){ return h.toLowerCase() === 'gate'; }),
          Plot:  headers.find(function(h){ return h === 'Plot'; }), // exact "Plot"
          Row:   headers.find(function(h){ return h.toLowerCase() === 'row'; }),
          Grave: headers.find(function(h){ return h.toLowerCase() === 'grave'; }),
          DateCreated: headers.find(function(h){ return h.toLowerCase() === 'datecreated'; }),
          Memorial: headers.find(function(h){ return h.toLowerCase() === 'memorial' || h.toLowerCase() === 'memorialid' || h.toLowerCase() === 'memorial id'; })
        };

        var missing = [];
        if (!COL.Block) missing.push('Block');
        if (!COL.Row)   missing.push('Row');
        if (!COL.Grave) missing.push('Grave');
        if (!COL.Gate)  missing.push('Gate');
        if (missing.length) {
          output.innerHTML = '<p class="error">Missing required column(s): ' + missing.join(', ') + '</p>';
          return;
        }

        allRows = data.slice(1)
          .filter(function(r){ return r.some(function(c){ return String(c).trim() !== ''; }); })
          .map(function(r){
            var obj = {};
            headers.forEach(function(h, i){ obj[h] = (r[i] == null ? '' : String(r[i]).trim()); });
            return obj;
          });

// Build Block list for combobox
var blocks = uniqueSorted(allRows.map(function(r){ return r[COL.Block]; }));

// ✅ Block change: reload page with new block; reset gate to All
initBlockCombo(blocks, {
  onConfirm: function(newBlock){
    setFiltersAndReload(newBlock || '', 'All');
  }
});     

        // Show controls
        filterWrap.style.display = 'flex';

        // Populate Gate menu based on URL's block (render uses URL)
        // and render the table from URL params
        renderForFilters();

        // Gate change => full reload with block + gate
        gateSelect.addEventListener('change', function(){
          var bv = String(blockInput.value || '').trim();  // live Block
          var gv = String(gateSelect.value || 'All').trim();
          setFiltersAndReload(bv, gv);
        });

      } catch (err) {
        output.innerHTML = '<p class="error">Failed to load requests.csv: ' + escapeHtml(err.message) + '</p>';
      }
    }
  </script>
</body>
</html>
