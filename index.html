<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Requests CSV Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; line-height: 1.35; padding: 18px; }
    label { font-weight: 600; }
    input[type="text"], select { margin-left: 6px; padding: 4px 6px; }
    table { border-collapse: collapse; margin-top: 16px; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; }
    th { background: #f6f6f6; position: sticky; top: 0; cursor: pointer; white-space: nowrap; }
    .controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; margin-bottom: 6px; }
    .error { color: #b00; }
    .note { color: #666; font-size: 0.9em; }

    th .sort-ind { font-size: 0.8em; opacity: 0.8; margin-left: 6px; display: inline-block; min-width: 1.2em; text-align: center; }
    th[data-sort-dir="1"] .sort-ind::after  { content: "▲"; }
    th[data-sort-dir="-1"] .sort-ind::after { content: "▼"; }
    th[data-sort-priority] .sort-prio::before {
      content: attr(data-sort-priority);
      font-size: 0.75em; border: 1px solid #aaa; border-radius: 999px; padding: 0 0.35em; margin-right: 4px; opacity: 0.8;
    }
  </style>
</head>
<body>
  <h2>Requests CSV Viewer</h2>

  <div class="controls" id="filterWrap" style="display:none;">
    <label for="blockInput">Block:</label>
    <input id="blockInput" type="text" list="blocksList" placeholder="Leave empty to show all Blocks…" />
    <datalist id="blocksList"></datalist>

    <span id="gateWrap">
      <label for="gateSelect">Gate:</label>
      <select id="gateSelect"></select>
    </span>

    <span id="secWrap" style="display:none;">
      <label for="secSelect">Section:</label>
      <select id="secSelect"></select>
    </span>
  </div>

  <span class="note">
    Click headers to sort; <b>Shift+Click</b> to add multi-column sorting.
  </span>

  <div id="output"></div>

  <script>
    /* ===== CSV parsing and utilities (same as before) ===== */
    function parseCSV(text) {
      var rows = [], row = [], field = '', i = 0, inQuotes = false;
      while (i < text.length) {
        var ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (text[i+1] === '"') { field += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          }
          field += ch; i++; continue;
        } else {
          if (ch === '"') { inQuotes = true; i++; continue; }
          if (ch === ',') { row.push(field); field=''; i++; continue; }
          if (ch === '\r') { i++; continue; }
          if (ch === '\n') { row.push(field); rows.push(row); row=[]; field=''; i++; continue; }
          field += ch; i++;
        }
      }
      row.push(field);
      if (!(row.length === 1 && row[0] === '' && rows.length > 0)) rows.push(row);
      while (rows.length && rows[rows.length-1].every(c => String(c).trim()==='')) rows.pop();
      return rows;
    }

    function naturalCompare(a, b) {
      var ax = String(a ?? '').trim();
      var bx = String(b ?? '').trim();
      if (ax === bx) return 0;
      var re = /(\d+|\D+)/g;
      var ta = ax.match(re) || [];
      var tb = bx.match(re) || [];
      var len = Math.max(ta.length, tb.length);
      for (var i = 0; i < len; i++) {
        var na = ta[i] ?? '';
        var nb = tb[i] ?? '';
        var ia = /^\d+$/.test(na);
        var ib = /^\d+$/.test(nb);
        if (ia && ib) {
          var da = parseInt(na, 10), db = parseInt(nb, 10);
          if (da !== db) return da - db;
        } else {
          if (na !== nb) return na.localeCompare(nb);
        }
      }
      return 0;
    }

    function parseDateMs(s) {
      if (!s) return NaN;
      var t = Date.parse(s);
      if (!isNaN(t)) return t;
      var m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
      if (m) {
        var mm = parseInt(m[1], 10)-1, dd = parseInt(m[2], 10), yy = parseInt(m[3], 10);
        if (yy < 100) yy += 2000;
        return new Date(yy, mm, dd).getTime();
      }
      return NaN;
    }

    function dateCompare(a, b) {
      var ta = parseDateMs(a), tb = parseDateMs(b);
      if (isNaN(ta) && isNaN(tb)) return 0;
      if (isNaN(ta)) return 1;
      if (isNaN(tb)) return -1;
      return ta - tb;
    }

    function comparatorForColumn(col) {
      return (col && col.toLowerCase() === 'datecreated') ? dateCompare : naturalCompare;
    }

    function escapeHtml(s) {
      return String(s ?? '').replace(/[&<>"']/g, c =>
        ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])
      );
    }

    function uniqueSorted(values) {
      const seen = {};
      values.forEach(v => { v = String(v ?? '').trim(); if (v) seen[v]=1; });
      return Object.keys(seen).sort(naturalCompare);
    }

    /* ===== State ===== */
    let allRows=[], headers=[], sortState=[];
    const ALWAYS_HIDE_LC=new Set(['birthdate','notes','problems','memorialid']);
    const HIDE_EXACT=new Set(['plot']);

    const blockInput=document.getElementById('blockInput');
    const blocksList=document.getElementById('blocksList');
    const gateWrap=document.getElementById('gateWrap');
    const gateSelect=document.getElementById('gateSelect');
    const secWrap=document.getElementById('secWrap');
    const secSelect=document.getElementById('secSelect');
    const output=document.getElementById('output');
    const filterWrap=document.getElementById('filterWrap');

    let COL={};

    /* ===== Table rendering ===== */
    function buildTable(container, headersToShow, rows) {
      let html='<table><thead><tr>';
      headersToShow.forEach(h=>{
        const idx=sortState.findIndex(s=>s.col===h);
        const prio=idx>=0?idx+1:''; const dir=idx>=0?String(sortState[idx].dir):'';
        html+=`<th data-col="${escapeHtml(h)}"${dir?` data-sort-dir="${dir}"`:''}${prio?` data-sort-priority="${prio}"`:''}>
                ${escapeHtml(h)}<span class="sort-ind"><span class="sort-prio"></span></span></th>`;
      });
      html+='</tr></thead><tbody>';
      rows.forEach(r=>{
        html+='<tr>';
        headersToShow.forEach(h=>{
          html+=`<td>${escapeHtml(r[h])}</td>`;
        });
        html+='</tr>';
      });
      html+='</tbody></table>';
      container.innerHTML=html;
      container.querySelectorAll("th").forEach(th=>{
        const pr=th.getAttribute("data-sort-priority");
        if(pr) th.querySelector(".sort-prio").textContent=pr;
      });
      attachHeaderSortHandlers(container);
    }

    function attachHeaderSortHandlers(container) {
      container.querySelectorAll("th").forEach(th=>{
        th.addEventListener("click",e=>{
          const col=th.dataset.col;
          const idx=sortState.findIndex(s=>s.col===col);
          if(e.shiftKey){
            if(idx===-1) sortState.push({col,dir:1});
            else sortState[idx].dir=-sortState[idx].dir;
          } else {
            if(idx===0 && sortState.length) sortState[0].dir=-sortState[0].dir;
            else sortState=[{col,dir:1}];
          }
          applyMultiSort(); buildTable(container,headers,allRowsFiltered);
        });
      });
    }

    function applyMultiSort() {
      if(!sortState.length) return;
      const comps=sortState.map(s=>({key:s.col,dir:s.dir,cmp:comparatorForColumn(s.col)}));
      allRowsFiltered.sort((a,b)=>{
        for(const c of comps){
          const res=c.cmp(a[c.key],b[c.key]);
          if(res) return res*c.dir;
        }
        return 0;
      });
    }

    /* ===== Filtering ===== */
    let allRowsFiltered=[];

    function populateDropdown(selectEl, values){
      let html='<option value="All">All</option>';
      values.forEach(v=>html+=`<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`);
      selectEl.innerHTML=html; selectEl.value='All';
    }

    function updateGateOrSectionUI(){
      if(blockInput.value.trim()==='84'){
        gateWrap.style.display='none'; secWrap.style.display='inline';
      } else {
        secWrap.style.display='none'; gateWrap.style.display='inline';
      }
    }

    function populateGateOrSectionDropdown(){
      const bv=blockInput.value.trim();
      let subset=allRows;
      if(bv) subset=allRows.filter(r=>String(r[COL.Block]||'').trim()===bv);
      if(bv==='84'){
        const secs=uniqueSorted(subset.map(r=>r[COL.Sec]));
        populateDropdown(secSelect,secs);
      } else {
        const gates=uniqueSorted(subset.map(r=>r[COL.Gate]));
        populateDropdown(gateSelect,gates);
      }
    }

  function renderForFilters(){
    var bv = String(blockInput.value || '').trim();
    var filtered = allRows.slice();

    // Block filter (skip if empty)
    if (bv) {
      filtered = filtered.filter(function(r){
        return String(r[COL.Block] || '').trim() === bv;
      });
    }

    if (bv === '84') {
      // Optional Section filter
      var sVal = String(secSelect.value || 'All').trim();
      if (sVal !== 'All' && sVal !== '') {
        filtered = filtered.filter(function(r){ return String(r[COL.Sec] || '').trim() === sVal; });
      }
      // Initial sort for Block 84
      filtered.sort(function(a,b){
        var s = naturalCompare(a[COL.Sec],  b[COL.Sec]);  if (s) return s;
        var r = naturalCompare(a[COL.Row],  b[COL.Row]);  if (r) return r;
        return naturalCompare(a[COL.Grave], b[COL.Grave]);
      });

    } else {
      // Optional Gate filter (also applies when Block is empty)
      var gVal = String(gateSelect.value || 'All').trim();
      if (gVal !== 'All' && gVal !== '') {
        filtered = filtered.filter(function(r){ return String(r[COL.Gate] || '').trim() === gVal; });
      }

      if (!bv) {
        // Block empty → default sort by Block first
        filtered.sort(function(a,b){
          var B = naturalCompare(a[COL.Block], b[COL.Block]); if (B) return B;
          var g = naturalCompare(a[COL.Gate],  b[COL.Gate]);  if (g) return g;
          var s = naturalCompare(a[COL.Sec],   b[COL.Sec]);   if (s) return s;
          var p = naturalCompare(a[COL.Plot],  b[COL.Plot]);  if (p) return p;
          var r = naturalCompare(a[COL.Row],   b[COL.Row]);   if (r) return r;
          return naturalCompare(a[COL.Grave],  b[COL.Grave]);
        });
      } else {
        // Non-84 block selected
        filtered.sort(function(a,b){
          var g = naturalCompare(a[COL.Gate], b[COL.Gate]); if (g) return g;
          var s = naturalCompare(a[COL.Sec],  b[COL.Sec]);  if (s) return s;
          var p = naturalCompare(a[COL.Plot], b[COL.Plot]); if (p) return p;
          var r = naturalCompare(a[COL.Row],  b[COL.Row]);  if (r) return r;
          return naturalCompare(a[COL.Grave], b[COL.Grave]);
        });
      }
    }

    // Visible columns
    var visible = headers.filter(function(h){
      if (ALWAYS_HIDE_LC.has(h.toLowerCase())) return false;
      if (HIDE_EXACT.has(h)) return false; // hide lowercase 'plot', keep 'Plot'
      return true;
    });
    if (bv === '84' && COL.Gate) {
      visible = visible.filter(function(h){ return h !== COL.Gate; });
    }

    // Inline "has any data" checks (no helper needed)
    var secHasData  = COL.Sec  && filtered.some(function(row){
      var v = row[COL.Sec];  return v != null && String(v).trim() !== '';
    });
    var plotHasData = COL.Plot && filtered.some(function(row){
      var v = row[COL.Plot]; return v != null && String(v).trim() !== '';
    });

    if (COL.Sec  && !secHasData)  visible = visible.filter(function(h){ return h !== COL.Sec; });
    if (COL.Plot && !plotHasData) visible = visible.filter(function(h){ return h !== COL.Plot; });

    // Reset user sort whenever filters change
    sortState = [];
    allRowsFiltered = filtered;
    buildTable(output, visible, filtered);
  }
    /* ===== Load CSV ===== */
    document.addEventListener('DOMContentLoaded',async()=>{
      const res=await fetch('requests.csv',{cache:'no-store'});
      const text=await res.text();
      const data=parseCSV(text);
      headers=data[0].map(h=>String(h).trim());
      COL={
        Block:headers.find(h=>h.toLowerCase()==='block'),
        Gate: headers.find(h=>h.toLowerCase()==='gate'),
        Sec:  headers.find(h=>['sec.','section','sec'].includes(h.toLowerCase())),
        Plot: headers.find(h=>h==='Plot'),
        Row:  headers.find(h=>h.toLowerCase()==='row'),
        Grave:headers.find(h=>h.toLowerCase()==='grave'),
        DateCreated:headers.find(h=>h.toLowerCase()==='datecreated')
      };
      allRows=data.slice(1).map(r=>{
        const obj={}; headers.forEach((h,i)=>obj[h]=r[i]??''); return obj;
      });

      const blocks=uniqueSorted(allRows.map(r=>r[COL.Block]));
      blocksList.innerHTML=blocks.map(v=>`<option value="${escapeHtml(v)}"></option>`).join('');

      filterWrap.style.display='flex';
      updateGateOrSectionUI();
      populateGateOrSectionDropdown();
      renderForFilters();
    });

    blockInput.addEventListener('input',()=>{
      updateGateOrSectionUI();
      populateGateOrSectionDropdown();
      renderForFilters();
    });
    gateSelect.addEventListener('change',renderForFilters);
    secSelect.addEventListener('change',renderForFilters);
  </script>
</body>
</html>
