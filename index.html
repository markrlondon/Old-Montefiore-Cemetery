<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Block → Row/Grave Sort</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .controls { display: flex; gap: 12px; align-items: center; margin: 16px 0; flex-wrap: wrap; }
    label { font-weight: 600; }
    select, input[type="file"] { padding: 6px 8px; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; }
    th { background: #f6f6f6; text-align: left; position: sticky; top: 0; }
    .counts { margin-left: auto; color: #555; }
  </style>
</head>
<body>
  <h2>CSV viewer with Block filter + Row/Grave sort</h2>

  <div class="controls">
    <input type="file" id="csvFile" accept=".csv" />
    <label for="blockSelect">Block:</label>
    <select id="blockSelect" disabled>
      <option value="__ALL__">All</option>
    </select>
    <div class="counts" id="counts"></div>
  </div>

  <div id="output"></div>

  <script>
    const csvInput    = document.getElementById("csvFile");
    const outputDiv   = document.getElementById("output");
    const blockSelect = document.getElementById("blockSelect");
    const countsEl    = document.getElementById("counts");

    let allRows = [];     // Array of row objects (header -> value)
    let headers = [];     // Header names in order
    let headerMap = {};   // lowercased header -> original header

    // RFC4180-ish CSV parser: handles quoted fields, commas, and escaped quotes ("").
    function parseCSV(text) {
      if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1); // strip UTF-8 BOM
      const rows = [];
      let row = [];
      let field = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (inQuotes) {
          if (char === '"') {
            const next = text[i + 1];
            if (next === '"') { field += '"'; i++; } else { inQuotes = false; }
          } else {
            field += char;
          }
        } else {
          if (char === '"') {
            inQuotes = true;
          } else if (char === ",") {
            row.push(field);
            field = "";
          } else if (char === "\r") {
            // ignore, handle on \n
          } else if (char === "\n") {
            row.push(field);
            rows.push(row);
            row = [];
            field = "";
          } else {
            field += char;
          }
        }
      }
      if (field.length > 0 || inQuotes || row.length > 0) {
        row.push(field);
        rows.push(row);
      }
      return rows.map(r => r.map(c => c.trim()));
    }

    // Natural/numeric-aware comparator with empty values pushed to the end
    const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: "base" });
    function cmpNatural(a, b) {
      const as = a == null ? "" : String(a).trim();
      const bs = b == null ? "" : String(b).trim();
      const aEmpty = as === "";
      const bEmpty = bs === "";
      if (aEmpty && bEmpty) return 0;
      if (aEmpty) return 1;   // push empties to end
      if (bEmpty) return -1;
      return collator.compare(as, bs);
    }

    function buildTable(rowsToShow) {
      if (!headers.length) return;

      let html = "<table><thead><tr>";
      headers.forEach(h => html += `<th>${escapeHtml(h)}</th>`);
      html += "</tr></thead><tbody>";

      rowsToShow.forEach(obj => {
        html += "<tr>";
        headers.forEach(h => html += `<td>${escapeHtml(obj[h] ?? "")}</td>`);
        html += "</tr>";
      });

      html += "</tbody></table>";
      outputDiv.innerHTML = html;

      countsEl.textContent = `Showing ${rowsToShow.length.toLocaleString()} of ${allRows.length.toLocaleString()} rows`;
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function mapHeaders(hdrs) {
      headerMap = {};
      hdrs.forEach(h => { headerMap[h.toLowerCase()] = h; });
      return headerMap;
    }

    function getColName(...candidates) {
      for (const c of candidates) {
        const found = headerMap[c.toLowerCase()];
        if (found) return found;
      }
      return null;
    }

    function populateBlockDropdown(blockCol) {
      const blockValues = new Set();
      let hasBlank = false;

      for (const row of allRows) {
        let v = row[blockCol];
        if (v == null || String(v).trim() === "") {
          hasBlank = true;
          continue;
        }
        blockValues.add(String(v).trim());
      }

      const sorted = Array.from(blockValues).sort((a,b) => collator.compare(a,b));
      blockSelect.innerHTML = `<option value="__ALL__">All</option>`;
      if (hasBlank) blockSelect.innerHTML += `<option value="__BLANK__">(blank)</option>`;
      for (const v of sorted) {
        blockSelect.innerHTML += `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`;
      }
      blockSelect.disabled = false;
    }

    function applyFilterAndSort() {
      // Resolve column names (case-insensitive): Block, row, grave/grav
      const blockCol = getColName("Block", "block");
      const rowCol   = getColName("row", "Row");
      const graveCol = getColName("grave", "grav", "Grave", "grav");

      let subset = allRows;
      const selected = blockSelect.value;

      if (selected === "__BLANK__") {
        subset = allRows.filter(r => {
          const v = r[blockCol];
          return v == null || String(v).trim() === "";
        });
      } else if (selected !== "__ALL__") {
        subset = allRows.filter(r => String(r[blockCol] ?? "").trim() === selected);
      }

      // Sort: primary by row, secondary by grave/grav
      subset = subset.slice().sort((a, b) => {
        const c1 = cmpNatural(rowCol ? a[rowCol] : "", rowCol ? b[rowCol] : "");
        if (c1 !== 0) return c1;
        return cmpNatural(graveCol ? a[graveCol] : "", graveCol ? b[graveCol] : "");
      });

      buildTable(subset);
    }

    csvInput.addEventListener("change", e => {
      const file = e.target.files?.[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = event => {
        const text = event.target.result;
        const csv = parseCSV(text).filter(r => r.length && r.some(c => c !== "")); // drop empty rows
        if (csv.length === 0) {
          outputDiv.textContent = "No data found in CSV.";
          blockSelect.disabled = true;
          countsEl.textContent = "";
          return;
        }

        headers = csv[0];
        mapHeaders(headers);

        // Figure out required columns; be flexible about casing/naming
        const blockCol = getColName("Block", "block");
        const rowCol   = getColName("row", "Row");
        const graveCol = getColName("grave", "grav", "Grave", "grav");

        if (!blockCol) {
          outputDiv.textContent = 'The CSV does not have a column named "Block" (case-insensitive).';
          blockSelect.disabled = true;
          countsEl.textContent = "";
          return;
        }
        if (!rowCol) {
          console.warn('No "row"/"Row" column found—sorting by row will be skipped.');
        }
        if (!graveCol) {
          console.warn('No "grave"/"grav" column found—secondary sort will be skipped.');
        }

        // Convert rows to objects
        allRows = csv.slice(1).map(row => {
          const obj = {};
          headers.forEach((h, i) => { obj[h] = row[i] ?? ""; });
          return obj;
        });

        populateBlockDropdown(blockCol);
        blockSelect.value = "__ALL__";
        applyFilterAndSort();
      };
      reader.readAsText(file);
    });

    blockSelect.addEventListener("change", applyFilterAndSort);
  </script>
</body>
</html>
