<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Requests CSV Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; line-height: 1.35; padding: 18px; }
    label { font-weight: 600; }
    select { margin-left: 6px; }
    table { border-collapse: collapse; margin-top: 16px; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 6px 8px; }
    th { background: #f6f6f6; position: sticky; top: 0; cursor: pointer; white-space: nowrap; }
    .controls { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .note { color: #666; font-size: 0.9em; }
    .error { color: #b00; }

    /* Sort indicators */
    th .sort-ind {
      font-size: 0.8em;
      opacity: 0.8;
      margin-left: 6px;
      display: inline-block;
      min-width: 1.2em;
      text-align: center;
    }
    th[data-sort-dir="1"] .sort-ind::after  { content: "▲"; }
    th[data-sort-dir="-1"] .sort-ind::after { content: "▼"; }
    th[data-sort-priority] .sort-prio::before {
      content: attr(data-sort-priority);
      font-size: 0.75em;
      border: 1px solid #aaa;
      border-radius: 999px;
      padding: 0 0.35em;
      margin-right: 4px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <h2>Requests CSV Viewer</h2>

  <div class="controls" id="blockFilterWrap" style="display:none;">
    <label for="blockSelect">Block:</label>
    <select id="blockSelect"></select>
    <span class="note">
      Non-84: Gate → Sec./Section → Plot → Row → Grave • 84: Sec./Section → Row → Grave (Gate hidden)
      <br>Click headers to sort; <b>Shift+Click</b> to add multi-column sorting.
    </span>
  </div>

  <div id="output"></div>

  <script>
    /* ===== CSV parsing (quotes & commas in quotes) ===== */
    function parseCSV(text) {
      var rows = [], row = [], field = '', i = 0, inQuotes = false;
      while (i < text.length) {
        var ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (text[i+1] === '"') { field += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          }
          field += ch; i++; continue;
        } else {
          if (ch === '"') { inQuotes = true; i++; continue; }
          if (ch === ',') { row.push(field); field=''; i++; continue; }
          if (ch === '\r') { i++; continue; }
          if (ch === '\n') { row.push(field); rows.push(row); row=[]; field=''; i++; continue; }
          field += ch; i++;
        }
      }
      row.push(field);
      if (!(row.length === 1 && row[0] === '' && rows.length > 0)) rows.push(row);
      while (rows.length && rows[rows.length-1].every(function(c){return String(c).trim()==='';})) rows.pop();
      return rows;
    }

    /* ===== Natural compare (handles 378/N, 8L, numbers, etc.) ===== */
    function naturalCompare(a, b) {
      var ax = String(a == null ? '' : a).trim();
      var bx = String(b == null ? '' : b).trim();
      if (ax === bx) return 0;
      var re = /(\d+|\D+)/g;
      var ta = ax.match(re) || [];
      var tb = bx.match(re) || [];
      var len = Math.max(ta.length, tb.length);
      for (var i = 0; i < len; i++) {
        var na = ta[i] != null ? ta[i] : '';
        var nb = tb[i] != null ? tb[i] : '';
        var ia = /^\d+$/.test(na);
        var ib = /^\d+$/.test(nb);
        if (ia && ib) {
          var da = parseInt(na, 10), db = parseInt(nb, 10);
          if (da !== db) return da - db;
        } else {
          if (na !== nb) return na.localeCompare(nb);
        }
      }
      return 0;
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, function(c){
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]);
      });
    }

    /* ===== State ===== */
    var allRows = [];      // all data rows (objects)
    var headers = [];      // all CSV headers (strings)
    var currentRows = [];  // filtered rows for the selected Block
    var currentHeaders = [];// visible headers after hiding logic
    var sortState = [];    // array of {col, dir} — primary first (dir: 1=asc, -1=desc)

    var ALWAYS_HIDE_LC = new Set(['birthdate','notes','problems','memorialid']);

    var blockWrap = document.getElementById('blockFilterWrap');
    var blockSelect = document.getElementById('blockSelect');
    var output = document.getElementById('output');

    function findHeader(candidates) {
      for (var k=0;k<candidates.length;k++) {
        var c = candidates[k].toLowerCase();
        for (var i=0;i<headers.length;i++) {
          if (headers[i].toLowerCase() === c) return headers[i];
        }
      }
      return null;
    }

    function hasAnyData(rows, header) {
      if (!header) return false;
      for (var i=0;i<rows.length;i++) {
        var v = rows[i][header];
        if (v != null && String(v).trim() !== '') return true;
      }
      return false;
    }

    /* ===== Build table with clickable (multi-sort) headers ===== */
    function buildTable(container, headersToShow, rows) {
      currentRows = rows.slice();
      currentHeaders = headersToShow.slice();

      var html = '<table><thead><tr>';
      headersToShow.forEach(function(h){
        // Add sort indicators: priority number + arrow; attributes used to restyle on refresh
        var existing = sortState.findIndex(function(s){ return s.col === h; });
        var prio = existing >= 0 ? (existing + 1) : '';
        var dir = existing >= 0 ? String(sortState[existing].dir) : '';
        html += '<th data-col="'+escapeHtml(h)+'"'
             +  (dir ? ' data-sort-dir="'+dir+'"' : '')
             +  (prio ? ' data-sort-priority="'+prio+'"' : '')
             +  '>'
             +  escapeHtml(h)
             +  '<span class="sort-ind"><span class="sort-prio"></span></span>'
             +  '</th>';
      });
      html += '</tr></thead><tbody>';
      rows.forEach(function(r){
        html += '<tr>';
        headersToShow.forEach(function(h){
          var cell = r[h];
          html += '<td>'+escapeHtml(cell == null ? '' : cell)+'</td>';
        });
        html += '</tr>';
      });
      html += '</tbody></table>';
      container.innerHTML = html;

      // Apply the displayed priority numbers (①,②,③… as plain digits)
      var ths = container.querySelectorAll("th");
      ths.forEach(function(th){
        var pr = th.getAttribute("data-sort-priority");
        if (pr) th.querySelector(".sort-prio").textContent = pr;
      });

      attachHeaderSortHandlers(container);
    }

    function attachHeaderSortHandlers(container) {
      var ths = container.querySelectorAll("th");
      ths.forEach(function(th){
        th.addEventListener("click", function(e){
          var col = th.getAttribute("data-col");
          var idx = sortState.findIndex(function(s){ return s.col === col; });

          if (e.shiftKey) {
            // Shift+Click: add or toggle this column without clearing others
            if (idx === -1) {
              sortState.push({ col: col, dir: 1 });
            } else {
              sortState[idx].dir = -sortState[idx].dir;
            }
          } else {
            // Normal click: make this the only key; if already primary, toggle
            if (idx === 0 && sortState.length > 0) {
              sortState[0].dir = -sortState[0].dir;
            } else {
              sortState = [{ col: col, dir: 1 }];
            }
          }

          applyMultiSort();
          // Rebuild table with preserved sort state indicators
          buildTable(container, currentHeaders, currentRows);
        });
      });
    }

    function applyMultiSort() {
      if (!sortState.length) return;

      // Stable sort: decorate with original index, sort, undecorate
      var decorated = currentRows.map(function(r, i){ return { r:r, i:i }; });
      decorated.sort(function(A, B){
        var a = A.r, b = B.r;
        for (var k=0;k<sortState.length;k++) {
          var key = sortState[k].col;
          var dir = sortState[k].dir;
          var cmp = naturalCompare(a[key], b[key]);
          if (cmp !== 0) return cmp * dir;
        }
        // stable fallback
        return A.i - B.i;
      });
      currentRows = decorated.map(function(x){ return x.r; });
    }

    /* ===== Load CSV and prepare UI ===== */
    async function loadCSV() {
      try {
        var res = await fetch('requests.csv', { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        var text = await res.text();
        var data = parseCSV(text);
        if (!data.length) { output.innerHTML = '<p class="error">No data found in requests.csv.</p>'; return; }

        headers = data[0].map(function(h){ return String(h).trim(); });

        // Resolve logical columns (support both "Sec." and "Section")
        var COL = {
          Block: findHeader(['Block']),
          Gate:  findHeader(['Gate']),
          Sec:   findHeader(['Sec.','Section','Sec']),
          Plot:  findHeader(['Plot']),
          Row:   findHeader(['Row']),
          Grave: findHeader(['Grave'])
        };

        // Minimal requirements
        var missing = [];
        if (!COL.Block) missing.push('Block');
        if (!COL.Row)   missing.push('Row');
        if (!COL.Grave) missing.push('Grave');
        if (!COL.Gate && !COL.Sec) missing.push('Gate (or Section/Sec.)');
        if (missing.length) {
          output.innerHTML = '<p class="error">Missing required column(s): ' + missing.join(', ') + '</p>';
          return;
        }

        allRows = data.slice(1)
          .filter(function(r){ return r.some(function(c){ return String(c).trim() !== ''; }); })
          .map(function(r){
            var obj = {};
            headers.forEach(function(h, i){ obj[h] = (r[i] == null ? '' : String(r[i]).trim()); });
            return obj;
          });

        // Build Block dropdown (unique, sorted)
        var blocksSet = {};
        for (var i=0;i<allRows.length;i++) {
          var bv = (allRows[i][COL.Block] || '').trim();
          if (bv) blocksSet[bv] = true;
        }
        var blocks = Object.keys(blocksSet).sort(naturalCompare);

        blockSelect.innerHTML = blocks.map(function(v){
          return '<option value="'+escapeHtml(v)+'">'+escapeHtml(v)+'</option>';
        }).join('');
        blockWrap.style.display = 'flex';
        output.innerHTML = '<p class="note">Choose a Block to display rows.</p>';

        blockSelect.dataset.cols = JSON.stringify(COL);

      } catch (err) {
        output.innerHTML = '<p class="error">Failed to load requests.csv: ' + escapeHtml(err.message) + '</p>';
      }
    }

    blockSelect.addEventListener('change', function(){ renderForBlock(blockSelect.value); });

    function renderForBlock(selected) {
      var COL = JSON.parse(blockSelect.dataset.cols || '{}');
      var filtered = allRows.filter(function(r){
        var v = r[COL.Block];
        return (v == null ? '' : v).trim() === selected;
      });

      // Initial sort (per your rules), before user-click sorting
      if (selected === '84') {
        filtered.sort(function(a,b){
          var s = naturalCompare(a[COL.Sec], b[COL.Sec]); if (s) return s;
          var r = naturalCompare(a[COL.Row], b[COL.Row]); if (r) return r;
          return naturalCompare(a[COL.Grave], b[COL.Grave]);
        });
      } else {
        filtered.sort(function(a,b){
          var g = naturalCompare(a[COL.Gate], b[COL.Gate]); if (g) return g;
          var s = naturalCompare(a[COL.Sec],  b[COL.Sec]);  if (s) return s;
          var p = naturalCompare(a[COL.Plot], b[COL.Plot]); if (p) return p;
          var r = naturalCompare(a[COL.Row],  b[COL.Row]);  if (r) return r;
          return naturalCompare(a[COL.Grave], b[COL.Grave]);
        });
      }

      // Visible columns: hide always-hidden; hide Gate for Block 84; show Sec/Plot only if present
      var visible = headers.filter(function(h){ return !ALWAYS_HIDE_LC.has(h.toLowerCase()); });
      if (selected === '84' && COL.Gate) visible = visible.filter(function(h){ return h !== COL.Gate; });

      var secHasData  = hasAnyData(filtered, COL.Sec);
      var plotHasData = hasAnyData(filtered, COL.Plot);
      if (COL.Sec  && !secHasData)  visible = visible.filter(function(h){ return h !== COL.Sec; });
      if (COL.Plot && !plotHasData) visible = visible.filter(function(h){ return h !== COL.Plot; });

      // Reset sort state whenever Block changes (fresh multi-sort)
      sortState = [];

      buildTable(output, visible, filtered);
    }

    document.addEventListener('DOMContentLoaded', async function(){
      await loadCSV();
      if (blockSelect.options.length) {
        blockSelect.selectedIndex = 0;
        renderForBlock(blockSelect.value);
      }
    });
  </script>
</body>
</html>
